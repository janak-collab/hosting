<?php
namespace App\Controllers;

use App\Models\Dictation;
use App\Services\ValidationService;

class DictationController {
    private $dictationModel;
    private $validator;
    
    public function __construct() {
        $this->dictationModel = new Dictation();
        $this->validator = new ValidationService();
    }
    
    /**
     * Display dictation form (with no-cache headers)
     */
    public function showForm() {
        // Set no-cache headers to prevent browser caching
        $this->setNoCacheHeaders();
        
        // Generate CSRF token
        if (!isset($_SESSION['csrf_token'])) {
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
        }
        
        // Get data for the form
        $providers = $this->dictationModel->getProviders();
        $locations = $this->dictationModel->getLocations();
        $categories = $this->dictationModel->getCategories();
        $csrf_token = $_SESSION['csrf_token'];
        
        // Log form access
        $this->dictationModel->createAuditLog([
            'action' => 'view_form',
            'metadata' => [
                'user' => $_SERVER['PHP_AUTH_USER'] ?? 'Unknown'
            ]
        ]);
        
        // Load the view
        require_once __DIR__ . '/../../templates/views/dictation/form.php';
    }
    
    /**
     * API: Get procedures for a provider (with no-cache headers)
     */
    public function getTemplates() {
        $this->setNoCacheHeaders();
        header('Content-Type: application/json');
        
        // Verify CSRF
        if (!$this->verifyCsrf()) {
            $this->jsonResponse([
                'success' => false,
                'error' => 'Invalid security token'
            ], 403);
            return;
        }
        
        $providerId = $_GET['provider_id'] ?? null;
        
        if (!$providerId) {
            $this->jsonResponse([
                'success' => false,
                'error' => 'Provider ID required'
            ], 400);
            return;
        }
        
        try {
            // Get procedures with provider customizations
            $procedures = $this->dictationModel->getActiveProcedures($providerId);
            
            // Get billing codes for each procedure
            foreach ($procedures as &$procedure) {
                $procedure['billing_codes'] = $this->dictationModel->getBillingCodes($procedure['id']);
            }
            
            // Log the action
            $this->dictationModel->createAuditLog([
                'action' => 'load_procedures',
                'provider_id' => $providerId,
                'metadata' => [
                    'procedure_count' => count($procedures)
                ]
            ]);
            
            $this->jsonResponse([
                'success' => true,
                'procedures' => $procedures
            ]);
            
        } catch (\Exception $e) {
            error_log("Get templates error: " . $e->getMessage());
            $this->jsonResponse([
                'success' => false,
                'error' => 'Failed to load procedures'
            ], 500);
        }
    }
    
    /**
     * API: Log audit entry (with no-cache headers)
     */
    public function logAudit() {
        $this->setNoCacheHeaders();
        header('Content-Type: application/json');
        
        // Accept both POST and beacon requests
        $data = [];
        if ($_SERVER['REQUEST_METHOD'] === 'POST') {
            $input = file_get_contents('php://input');
            $data = json_decode($input, true) ?: $_POST;
        }
        
        // Validate required fields
        if (empty($data['action'])) {
            $this->jsonResponse([
                'success' => false,
                'error' => 'Action required'
            ], 400);
            return;
        }
        
        try {
            // Sanitize input
            $auditData = [
                'action' => $this->validator->sanitize($data['action']),
                'procedure_id' => isset($data['procedure_id']) ? intval($data['procedure_id']) : null,
                'procedure_name' => isset($data['procedure_name']) ? $this->validator->sanitize($data['procedure_name']) : null,
                'provider_id' => isset($data['provider_id']) ? intval($data['provider_id']) : null,
                'provider_name' => isset($data['provider_name']) ? $this->validator->sanitize($data['provider_name']) : null,
                'location' => isset($data['location']) ? $this->validator->sanitize($data['location']) : null,
                'duration_seconds' => isset($data['duration_seconds']) ? intval($data['duration_seconds']) : null,
                'dictation_count' => isset($data['dictation_count']) ? intval($data['dictation_count']) : null,
                'metadata' => $data['metadata'] ?? []
            ];
            
            $result = $this->dictationModel->createAuditLog($auditData);
            
            $this->jsonResponse([
                'success' => $result
            ]);
            
        } catch (\Exception $e) {
            error_log("Audit log error: " . $e->getMessage());
            $this->jsonResponse([
                'success' => false,
                'error' => 'Failed to log audit entry'
            ], 500);
        }
    }
    
    /**
     * Set no-cache headers to prevent browser caching
     */
    private function setNoCacheHeaders() {
        header('Cache-Control: no-store, no-cache, must-revalidate, max-age=0');
        header('Cache-Control: post-check=0, pre-check=0', false);
        header('Pragma: no-cache');
        header('Expires: 0');
    }
    
    /**
     * Verify CSRF token
     */
    private function verifyCsrf() {
        $token = $_SERVER['HTTP_X_CSRF_TOKEN'] ?? $_POST['csrf_token'] ?? '';
        return isset($_SESSION['csrf_token']) && hash_equals($_SESSION['csrf_token'], $token);
    }
    
    /**
     * Send JSON response
     */
    private function jsonResponse($data, $status = 200) {
        http_response_code($status);
        echo json_encode($data);
        exit;
    }
}
